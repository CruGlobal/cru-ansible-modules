#!/opt/rh/python27/root/usr/bin/python

from ansible.module_utils.basic import *
from ansible.module_utils.facts import *
from ansible.module_utils.basic import AnsibleModule
import subprocess
import sys, os, json, re, time, commands, datetime, calendar
from subprocess import (PIPE, Popen)
from dateutil.relativedelta import relativedelta


ANSIBLE_METADATA = {'status': ['stableinterface'],
                    'supported_by': 'Cru DBA team',
                    'version': '0.1'}

DOCUMENTATION = '''
---
module: utilstimediff
short_description: Calculate diff between current time and ans_run_start.

description: This module will capture current time when called and if
    ans_run_start is defined, it will calculate the difference between
    current time and ans_run_start and output it to the user.

requirements: [ python => 2.6 ]
author: "DBA Oracle module Team"
'''

EXAMPLES = '''

    Utils* generates a variable called ans_run_start
    when the show command or run button is pressed.
    ans_run_start captures the current date and time
    as a starting point for timing the complete process.
    The time is captured just before the Ansible command is
    executed.

    Ex. of ans_run_start format generated by utils:
        ans_run_start="Wed Nov 13 13:47:13 EST"

    This module can be placed anywhere in the playbook.
    when called it will capture current time and output the difference
    between the current time and start time.

    Ex. of what a task in a playbook might look like using this module:

    - name: Run time check point
      utilstimediff:
        start_time: "{{ ans_run_start }}"
        refname: fin_time
        debugging: False
      when:
        - ans_run_start is defined

    # This module returns a dictionary that can be referenced by the default
      reference name for this module: 'utilstimediff' or by whatever reference
      name you provide with the optional 'refname' parameter.

      The dictionary looks like this
      { 'hrs': <hours> , 'min': <minutes>, 'sec': <seconds>, 'total': <00:00:00> }

    # Something like this task it optional:

    - pause:
      prompt: |
        "

            =====================================================================

                      Utils {{ fx }} run time:
                          ( HR:MI:SS )
                            {{ '%02d' | format( timediff.hrs|int ) }}:{{ '%02d' | format( timediff.min|int ) }}:{{ '%02d' | format( timediff.sec|int ) }}

                       or

                            {{ timediff.total }}

                      ** From the time you hit the utils 'Run' button until now.

            =====================================================================

         "
      when:
        - master_node|bool
        - fin_time is defined
      tags: always

    * 'utils' is a GUI interface with Ansible play options used to launch
      the Ansible plays that call these modules.



'''

msg=""
vdebugme = False
vlogit = False
refname = "timediff"

def add_to_msg(in_str):
    """Add an input string to the global msg string"""
    global msg

    if msg:
        msg = msg + " " + in_str
    else:
        msg = in_str

    return


def debugg(in_str):
    global vdebugme
    global vlogit

    if vdebugme:
        add_to_msg(in_str)

        if vlogit:
            with open("/u01/oracle/finrest.log","a") as f:
                f.write("%s\n" % (in_str))
                f.close()

    return


def run_sub(cmd_str):
    """Run a command using the subprocess
       module on the localhost
    """

    debugg("run_sub() ...starting... with cmd_str= %s" % (cmd_str))

    try:
        process = subprocess.Popen([cmd_str], stdout=PIPE, stderr=PIPE, shell=True)
        (output, code) = process.communicate()
    except subprocess.CalledProcessError as e:
        if global_debugFile:
            err_msg = "common::run_command() : [ERROR]: output = %s, error code = %s\n".format(e.output, e.returncode)
            debugg(None, "Error running global run_sub. cmd_str={} Error: {}".format(cmd_str,err_msg))
        else:
            tellUser("Error running cmd: {} Error info: {}".format(cmd_str,err_msg))

    # results = output.decode('ascii').strip()
    results = output.encode('ascii', 'ignore').strip()

    debugg("run_sub()...exiting....output=%s code=%s" % (results, str(code)))

    return(results)


def monthtoNum(short_mon):
    """Given an abbreviation for a month, return its number equivelent"""
    ret_num = [ num for num, name in enumerate(calendar.month_abbr) if name == short_mon ][0]
    return(ret_num)


def purge_clutter(in_list):
    """Given a list of date time items of format:
        ['Wed', 'Nov', '13', '13:47:13', 'EST', '2019']
       delete times 0 (Wed) then item 3 ( EST )
    """
    debugg("purge_clutter...start....in_list=%s" % (str(in_list)))
    del in_list[0]
    debugg("purge_clutter...purged[0]....in_list=%s" % (str(in_list)))
    del in_list[3]
    debugg("purge_clutter...exiting..purged[3]....in_list=%s" % (str(in_list)))
    return(in_list)


def date_to_dict(in_list):
    """Given a list of date time items of format:
        [Nov', '13', '13:47:13', '2019']
       put in dictionary to reference: '%Y-%m-%d %H:%M:%S' and return
    """
    d = {}

    mnth = pad_zeros(monthtoNum(in_list[0]))

    hr,min,sec = in_list[2].split(":")

    hr = pad_zeros(hr)
    min = pad_zeros(min)
    sec = pad_zeros(sec)

    d.update({ 'y': in_list[3], 'm': mnth , 'd': in_list[1], 'h': hr, 'min': min, 's': sec})
    debugg("date_to_dict=%s" % (str(in_list)))
    return(d)


def pad_zeros(in_item):
    """given a string with digit < 10 pad with zeros"""
    a = ""
    if int(in_item) < 10 and "0" not in in_item:
        a = "0%s" % (in_item)
    else:
        a = in_item

    return(a)


def to_bool(in_str):
    """Given an input string return True of False:
       Expected intput:
        Y,y,yes,N,n,no,No,True,true,t,False,false,f,F
    """
    affirm = ['True','true','t','T','Yes','yes','y','Y']

    if in_str in affirm:
        return(True)
    else:
        return(False)


# ==============================================================================
# =================================== MAIN =====================================
# ==============================================================================
def main(argv):
    global msg
    global vdebugme
    global vlogit
    global refname
    divider = "="
    weekday = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']

    ansible_facts={}

    # os.system("/usr/bin/scl enable python27 bash")

    module = AnsibleModule(
      argument_spec = dict(
        start_time     = dict(required=True),
        refname        = dict(required=False),
        debugging      = dict(required=False)
      ),
      supports_check_mode=False,
    )

    # Get arguements passed from Ansible playbook
    vstart_time  = module.params.get('start_time')
    vrefname     = module.params.get('refname')
    vdebug       = module.params.get('debugging')

    if to_bool(vdebug):
        add_to_msg("=====>>> vdebug: %s" % (vdebug))
        vdebugme = True
        if vdebug == "log":
            vlogit = True

    debugg("vdebug = %s and vlogit = %s vdebugme = %s" % (vdebug,vlogit,vdebugme))

    if vrefname:
        refname = vrefname

    ansible_facts = { refname: { } }

    # start_time= ans_run_start = "Wed Nov 13 13:47:13 EST 2019"
    # ckpt_time                    "Wed Nov 13 14:19:12 EST 2019"
    cmd_str = "date"
    ckpt_time = run_sub(cmd_str)
    debugg("vdebugme = %s" % (vdebugme))
    debugg("ckpt_time: %s" % (str(ckpt_time)))

    # _start = ['Wed', 'Nov', '13', '13:47:13', 'EST', '2019']
    _start = vstart_time.split()
    _now = ckpt_time.split()

    # removing weekday and EST from list:
    # ['Nov', '13', '13:47:13', '2019']
    s1 = purge_clutter(_start)
    n1 = purge_clutter(_now)

    debugg("s = %s n = %s" % (str(s1),str(n1)))

    s = date_to_dict(s1)
    n = date_to_dict(n1)

    debugg("s = %s n = %s" % (s,n))

    # { 'y': in_list[3], 'm': mnth , 'd': in_list[1], 'h': hr, 'min': min, 's': sec}
    frmt_start = "%s-%s-%s %s:%s:%s" % (s['y'],s['m'],s['d'],s['h'],s['m'],s['s'])
    frmt_now = "%s-%s-%s %s:%s:%s" % (n['y'],n['m'],n['d'],n['h'],n['m'],n['s'])

    new_start = datetime.datetime.strptime(frmt_start, '%Y-%m-%d %H:%M:%S')
    new_now = datetime.datetime.strptime(frmt_now, '%Y-%m-%d %H:%M:%S')

    # diff => (hours=+2, minutes=+59, seconds=+57)
    diff = relativedelta( new_now, new_start)

    tot_run = "%02d:%02d:%02d" % (int(diff.hours),int(diff.minutes),int(diff.seconds))

    ansible_facts[refname].update( { 'hrs': diff.hours, 'min': diff.minutes, 'sec': diff.seconds, 'total': tot_run } )

    add_to_msg("Checkpoint time difference : %s " % (str(diff)))

    add_to_msg("utilstimediff completed successfully.")

    module.exit_json( msg=msg , ansible_facts=ansible_facts , changed="False")

# code to execute if this program is called directly
if __name__ == "__main__":
    main(sys.argv)
